
R version 3.2.1 (2015-06-18) -- "World-Famous Astronaut"
Copyright (C) 2015 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin13.4.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> ## For examples skipped in testing because they are 'random'
> 
> set.seed(1)
> if(.Platform$OS.type == "windows") options(pager = "console")
> 
> pdf("reg-examples-1.pdf", encoding = "ISOLatin1.enc")
> 
> 
> ## base
> example(Cstack_info, run.donttest = TRUE)

Cstck_> ## No test: 
Cstck_> Cstack_info()
      size    current  direction eval_depth 
   7969177      20040          1          9 

Cstck_> ## End(No test)
Cstck_> 
Cstck_> 
> example(DateTimeClasses, run.donttest = TRUE)

DtTmCl> ## No test: 
DtTmCl> (z <- Sys.time())             # the current date, as class "POSIXct"
[1] "2015-07-17 17:34:45 PDT"

DtTmCl> Sys.time() - 3600             # an hour ago
[1] "2015-07-17 16:34:45 PDT"

DtTmCl> as.POSIXlt(Sys.time(), "GMT") # the current time in GMT
[1] "2015-07-18 00:34:45 GMT"

DtTmCl> format(.leap.seconds)         # the leap seconds in your time zone
 [1] "1972-06-30 17:00:00" "1972-12-31 16:00:00" "1973-12-31 16:00:00"
 [4] "1974-12-31 16:00:00" "1975-12-31 16:00:00" "1976-12-31 16:00:00"
 [7] "1977-12-31 16:00:00" "1978-12-31 16:00:00" "1979-12-31 16:00:00"
[10] "1981-06-30 17:00:00" "1982-06-30 17:00:00" "1983-06-30 17:00:00"
[13] "1985-06-30 17:00:00" "1987-12-31 16:00:00" "1989-12-31 16:00:00"
[16] "1990-12-31 16:00:00" "1992-06-30 17:00:00" "1993-06-30 17:00:00"
[19] "1994-06-30 17:00:00" "1995-12-31 16:00:00" "1997-06-30 17:00:00"
[22] "1998-12-31 16:00:00" "2005-12-31 16:00:00" "2008-12-31 16:00:00"
[25] "2012-06-30 17:00:00"

DtTmCl> print(.leap.seconds, tz = "PST8PDT")  # and in Seattle's
 [1] "1972-06-30 17:00:00 PDT" "1972-12-31 16:00:00 PST"
 [3] "1973-12-31 16:00:00 PST" "1974-12-31 16:00:00 PST"
 [5] "1975-12-31 16:00:00 PST" "1976-12-31 16:00:00 PST"
 [7] "1977-12-31 16:00:00 PST" "1978-12-31 16:00:00 PST"
 [9] "1979-12-31 16:00:00 PST" "1981-06-30 17:00:00 PDT"
[11] "1982-06-30 17:00:00 PDT" "1983-06-30 17:00:00 PDT"
[13] "1985-06-30 17:00:00 PDT" "1987-12-31 16:00:00 PST"
[15] "1989-12-31 16:00:00 PST" "1990-12-31 16:00:00 PST"
[17] "1992-06-30 17:00:00 PDT" "1993-06-30 17:00:00 PDT"
[19] "1994-06-30 17:00:00 PDT" "1995-12-31 16:00:00 PST"
[21] "1997-06-30 17:00:00 PDT" "1998-12-31 16:00:00 PST"
[23] "2005-12-31 16:00:00 PST" "2008-12-31 16:00:00 PST"
[25] "2012-06-30 17:00:00 PDT"

DtTmCl> ## look at *internal* representation of "POSIXlt" :
DtTmCl> leapS <- as.POSIXlt(.leap.seconds)

DtTmCl> names(leapS) ; is.list(leapS)
NULL
[1] TRUE

DtTmCl> ## str() "too smart" -->  need unclass(.):
DtTmCl> utils::str(unclass(leapS), vec.len = 7)
List of 11
 $ sec   : num [1:25] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ...
 $ min   : int [1:25] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ...
 $ hour  : int [1:25] 17 16 16 16 16 16 16 16 16 17 17 17 17 16 16 16 17 17 ...
 $ mday  : int [1:25] 30 31 31 31 31 31 31 31 31 30 30 30 30 31 31 31 30 30 ...
 $ mon   : int [1:25] 5 11 11 11 11 11 11 11 11 5 5 5 5 11 11 11 5 5 ...
 $ year  : int [1:25] 72 72 73 74 75 76 77 78 79 81 82 83 85 87 89 90 92 93 ...
 $ wday  : int [1:25] 5 0 1 2 3 5 6 0 1 2 3 4 0 4 0 1 2 3 ...
 $ yday  : int [1:25] 181 365 364 364 364 365 364 364 364 180 180 180 180 364 364 364 181 180 ...
 $ isdst : int [1:25] 1 0 0 0 0 0 0 0 0 1 1 1 1 0 0 0 1 1 ...
 $ zone  : chr [1:25] "PDT" "PST" "PST" "PST" "PST" "PST" "PST" ...
 $ gmtoff: int [1:25] -25200 -28800 -28800 -28800 -28800 -28800 -28800 -28800 -28800 -25200 -25200 -25200 -25200 -28800 -28800 -28800 -25200 -25200 ...
 - attr(*, "tzone")= chr [1:3] "" "PST" "PDT"

DtTmCl> ## End(No test)
DtTmCl> 
DtTmCl> 
> example(Dates, run.donttest = TRUE)

Dates> ## No test: 
Dates> (today <- Sys.Date())
[1] "2015-07-17"

Dates> format(today, "%d %b %Y")  # with month as a word
[1] "17 Jul 2015"

Dates> (tenweeks <- seq(today, length.out=10, by="1 week")) # next ten weeks
 [1] "2015-07-17" "2015-07-24" "2015-07-31" "2015-08-07" "2015-08-14"
 [6] "2015-08-21" "2015-08-28" "2015-09-04" "2015-09-11" "2015-09-18"

Dates> weekdays(today)
[1] "Friday"

Dates> months(tenweeks)
 [1] "July"      "July"      "July"      "August"    "August"    "August"   
 [7] "August"    "September" "September" "September"

Dates> as.Date(.leap.seconds)
 [1] "1972-07-01" "1973-01-01" "1974-01-01" "1975-01-01" "1976-01-01"
 [6] "1977-01-01" "1978-01-01" "1979-01-01" "1980-01-01" "1981-07-01"
[11] "1982-07-01" "1983-07-01" "1985-07-01" "1988-01-01" "1990-01-01"
[16] "1991-01-01" "1992-07-01" "1993-07-01" "1994-07-01" "1996-01-01"
[21] "1997-07-01" "1999-01-01" "2006-01-01" "2009-01-01" "2012-07-01"

Dates> ## End(No test)
Dates> 
Dates> 
> example(Ops.Date, run.donttest = TRUE)

Ops.Dt> ## No test: 
Ops.Dt> (z <- Sys.Date())
[1] "2015-07-17"

Ops.Dt> z + 10
[1] "2015-07-27"

Ops.Dt> z < c("2009-06-01", "2010-01-01", "2015-01-01")
[1] FALSE FALSE FALSE

Ops.Dt> ## End(No test)
Ops.Dt> 
Ops.Dt> 
> example(Random, run.donttest = TRUE)

Random> ## No test: 
Random> require(stats)

Random> ## the default random seed is 626 integers, so only print a few
Random> runif(1); .Random.seed[1:6]; runif(1); .Random.seed[1:6]
[1] 0.2655087
[1]         403           1  1654269195 -1877109783  -961256264  1403523942
[1] 0.3721239
[1]         403           2  1654269195 -1877109783  -961256264  1403523942

Random> ## If there is no seed, a "random" new one is created:
Random> rm(.Random.seed); runif(1); .Random.seed[1:6]
[1] 0.9059457
[1]        403          1  -54549011  181053991 -566490546 -451555672

Random> ok <- RNGkind()

Random> RNGkind("Wich")  # (partial string matching on 'kind')

Random> ## This shows how 'runif(.)' works for Wichmann-Hill,
Random> ## using only R functions:
Random> 
Random> p.WH <- c(30269, 30307, 30323)

Random> a.WH <- c(  171,   172,   170)

Random> next.WHseed <- function(i.seed = .Random.seed[-1])
Random+   { (a.WH * i.seed) %% p.WH }

Random> my.runif1 <- function(i.seed = .Random.seed)
Random+   { ns <- next.WHseed(i.seed[-1]); sum(ns / p.WH) %% 1 }

Random> rs <- .Random.seed

Random> (WHs <- next.WHseed(rs[-1]))
[1] 15387  1200  2798

Random> u <- runif(1)

Random> stopifnot(
Random+  next.WHseed(rs[-1]) == .Random.seed[-1],
Random+  all.equal(u, my.runif1(rs))
Random+ )

Random> ## ----
Random> .Random.seed
[1]   400 15387  1200  2798

Random> RNGkind("Super") # matches  "Super-Duper"

Random> RNGkind()
[1] "Super-Duper" "Inversion"  

Random> .Random.seed # new, corresponding to  Super-Duper
[1]         402 -1209376131 -1876019429

Random> ## Reset:
Random> RNGkind(ok[1])

Random> ## ----
Random> sum(duplicated(runif(1e6))) # around 110 for default generator
[1] 116

Random> ## and we would expect about almost sure duplicates beyond about
Random> qbirthday(1 - 1e-6, classes = 2e9) # 235,000
[1] 235075

Random> ## End(No test)
Random> 
Random> 
> example(Sys.getpid, run.donttest = TRUE)

Sys.gt> ## No test: 
Sys.gt> Sys.getpid()
[1] 73836

Sys.gt> ## End(No test)
Sys.gt> 
Sys.gt> 
> example(Sys.sleep, run.donttest = TRUE)

Sys.sl> ## No test: 
Sys.sl> testit <- function(x)
Sys.sl+ {
Sys.sl+     p1 <- proc.time()
Sys.sl+     Sys.sleep(x)
Sys.sl+     proc.time() - p1 # The cpu usage should be negligible
Sys.sl+ }

Sys.sl> testit(3.7)
   user  system elapsed 
  0.000   0.000   3.705 

Sys.sl> ## End(No test)
Sys.sl> 
Sys.sl> 
> example(Sys.time, run.donttest = TRUE)

Sys.tm> ## No test: 
Sys.tm> Sys.time()
[1] "2015-07-17 17:34:49 PDT"

Sys.tm> ## print with possibly greater accuracy:
Sys.tm> op <- options(digits.secs = 6)

Sys.tm> Sys.time()
[1] "2015-07-17 17:34:49.621134 PDT"

Sys.tm> options(op)

Sys.tm> ## locale-specific version of date()
Sys.tm> format(Sys.time(), "%a %b %d %X %Y")
[1] "Fri Jul 17 17:34:49 2015"

Sys.tm> Sys.Date()
[1] "2015-07-17"

Sys.tm> ## End(No test)
Sys.tm> 
Sys.tm> 
> example(as.POSIXlt, run.donttest = TRUE)

a.POSI> ## No test: 
a.POSI> (z <- Sys.time())             # the current datetime, as class "POSIXct"
[1] "2015-07-17 17:34:49 PDT"

a.POSI> unclass(z)                    # a large integer
[1] 1437179690

a.POSI> floor(unclass(z)/86400)       # the number of days since 1970-01-01 (UTC)
[1] 16634

a.POSI> (now <- as.POSIXlt(Sys.time())) # the current datetime, as class "POSIXlt"
[1] "2015-07-17 17:34:49 PDT"

a.POSI> unlist(unclass(now))          # a list shown as a named vector
               sec                min               hour               mday 
"49.6411190032959"               "34"               "17"               "17" 
               mon               year               wday               yday 
               "6"              "115"                "5"              "197" 
             isdst               zone             gmtoff 
               "1"              "PDT"           "-25200" 

a.POSI> now$year + 1900               # see ?DateTimeClasses
[1] 2015

a.POSI> months(now); weekdays(now)    # see ?months
[1] "July"
[1] "Friday"

a.POSI> ## suppose we have a time in seconds since 1960-01-01 00:00:00 GMT
a.POSI> ## (the origin used by SAS)
a.POSI> z <- 1472562988

a.POSI> # ways to convert this
a.POSI> as.POSIXct(z, origin = "1960-01-01")                # local
[1] "2006-08-30 06:16:28 PDT"

a.POSI> as.POSIXct(z, origin = "1960-01-01", tz = "GMT")    # in UTC
[1] "2006-08-30 13:16:28 GMT"

a.POSI> ## SPSS dates (R-help 2006-02-16)
a.POSI> z <- c(10485849600, 10477641600, 10561104000, 10562745600)

a.POSI> as.Date(as.POSIXct(z, origin = "1582-10-14", tz = "GMT"))
[1] "1915-01-26" "1914-10-23" "1917-06-15" "1917-07-04"

a.POSI> ## Stata date-times: milliseconds since 1960-01-01 00:00:00 GMT
a.POSI> ## format %tc excludes leap-seconds, assumed here
a.POSI> ## For format %tC including leap seconds, see foreign::read.dta()
a.POSI> z <- 1579598122120

a.POSI> op <- options(digits.secs = 3)

a.POSI> # avoid rounding down: milliseconds are not exactly representable
a.POSI> as.POSIXct((z+0.1)/1000, origin = "1960-01-01")
[1] "2010-01-20 01:15:22.120 PST"

a.POSI> options(op)

a.POSI> ## Matlab 'serial day number' (days and fractional days)
a.POSI> z <- 7.343736909722223e5 # 2010-08-23 16:35:00

a.POSI> as.POSIXct((z - 719529)*86400, origin = "1970-01-01", tz = "UTC")
[1] "2010-08-23 16:35:00 UTC"

a.POSI> as.POSIXlt(Sys.time(), "GMT") # the current time in UTC
[1] "2015-07-18 00:34:49 GMT"

a.POSI> ## End(No test)
a.POSI> ## No test: 
a.POSI> ## These may not be correct names on your system
a.POSI> as.POSIXlt(Sys.time(), "America/New_York")  # in New York
[1] "2015-07-17 20:34:49 EDT"

a.POSI> as.POSIXlt(Sys.time(), "EST5EDT")           # alternative.
[1] "2015-07-17 20:34:49 EDT"

a.POSI> as.POSIXlt(Sys.time(), "EST" )   # somewhere in Eastern Canada
[1] "2015-07-17 19:34:49 EST"

a.POSI> as.POSIXlt(Sys.time(), "HST")    # in Hawaii
[1] "2015-07-17 14:34:49 HST"

a.POSI> as.POSIXlt(Sys.time(), "Australia/Darwin")
[1] "2015-07-18 10:04:49 ACST"

a.POSI> ## End(No test)
a.POSI> 
a.POSI> 
> example(difftime, run.donttest = TRUE)

difftm> ## No test: 
difftm> (z <- Sys.time() - 3600)
[1] "2015-07-17 16:34:49 PDT"

difftm> Sys.time() - z                # just over 3600 seconds.
Time difference of 1 hours

difftm> ## time interval between release days of R 1.2.2 and 1.2.3.
difftm> ISOdate(2001, 4, 26) - ISOdate(2001, 2, 26)
Time difference of 59 days

difftm> as.difftime(c("0:3:20", "11:23:15"))
Time differences in mins
[1]   3.333333 683.250000

difftm> as.difftime(c("3:20", "23:15", "2:"), format = "%H:%M") # 3rd gives NA
Time differences in hours
[1]  3.333333 23.250000        NA

difftm> (z <- as.difftime(c(0,30,60), units = "mins"))
Time differences in mins
[1]  0 30 60

difftm> as.numeric(z, units = "secs")
[1]    0 1800 3600

difftm> as.numeric(z, units = "hours")
[1] 0.0 0.5 1.0

difftm> format(z)
[1] " 0 mins" "30 mins" "60 mins"

difftm> ## End(No test)
difftm> 
difftm> 
> example(format.Date, run.donttest = TRUE)

frmt.D> ## No test: 
frmt.D> ## locale-specific version of the date
frmt.D> format(Sys.Date(), "%a %b %d")
[1] "Fri Jul 17"

frmt.D> ## End(No test)
frmt.D> 
frmt.D> ## read in date info in format 'ddmmmyyyy'
frmt.D> ## This will give NA(s) in some locales; setting the C locale
frmt.D> ## as in the commented lines will overcome this on most systems.
frmt.D> ## lct <- Sys.getlocale("LC_TIME"); Sys.setlocale("LC_TIME", "C")
frmt.D> x <- c("1jan1960", "2jan1960", "31mar1960", "30jul1960")

frmt.D> z <- as.Date(x, "%d%b%Y")

frmt.D> ## Sys.setlocale("LC_TIME", lct)
frmt.D> z
[1] "1960-01-01" "1960-01-02" "1960-03-31" "1960-07-30"

frmt.D> ## read in date/time info in format 'm/d/y'
frmt.D> dates <- c("02/27/92", "02/27/92", "01/14/92", "02/28/92", "02/01/92")

frmt.D> as.Date(dates, "%m/%d/%y")
[1] "1992-02-27" "1992-02-27" "1992-01-14" "1992-02-28" "1992-02-01"

frmt.D> ## date given as number of days since 1900-01-01 (a date in 1989)
frmt.D> as.Date(32768, origin = "1900-01-01")
[1] "1989-09-19"

frmt.D> ## Excel is said to use 1900-01-01 as day 1 (Windows default) or
frmt.D> ## 1904-01-01 as day 0 (Mac default), but this is complicated by Excel
frmt.D> ## incorrectly treating 1900 as a leap year.
frmt.D> ## So for dates (post-1901) from Windows Excel
frmt.D> as.Date(35981, origin = "1899-12-30") # 1998-07-05
[1] "1998-07-05"

frmt.D> ## and Mac Excel
frmt.D> as.Date(34519, origin = "1904-01-01") # 1998-07-05
[1] "1998-07-05"

frmt.D> ## (these values come from http://support.microsoft.com/kb/214330)
frmt.D> 
frmt.D> ## Experiment shows that Matlab's origin is 719529 days before ours,
frmt.D> ## (it takes the non-existent 0000-01-01 as day 1)
frmt.D> ## so Matlab day 734373 can be imported as
frmt.D> as.Date(734373, origin = "1970-01-01") - 719529 # 2010-08-23
[1] "2010-08-23"

frmt.D> ## (value from 
frmt.D> ## http://www.mathworks.de/de/help/matlab/matlab_prog/represent-date-and-times-in-MATLAB.html)
frmt.D> 
frmt.D> ## Time zone effect
frmt.D> z <- ISOdate(2010, 04, 13, c(0,12)) # midnight and midday UTC

frmt.D> as.Date(z) # in UTC
[1] "2010-04-13" "2010-04-13"

frmt.D> ## No test: 
frmt.D> ## these time zone names are common
frmt.D> as.Date(z, tz = "NZ")
[1] "2010-04-13" "2010-04-14"

frmt.D> as.Date(z, tz = "HST") # Hawaii
[1] "2010-04-12" "2010-04-13"

frmt.D> ## End(No test)
frmt.D> 
frmt.D> 
frmt.D> 
> example(Reduce, run.donttest = TRUE) # funprog.Rd

Reduce> ## A general-purpose adder:
Reduce> add <- function(x) Reduce("+", x)

Reduce> add(list(1, 2, 3))
[1] 6

Reduce> ## Like sum(), but can also used for adding matrices etc., as it will
Reduce> ## use the appropriate '+' method in each reduction step.
Reduce> ## More generally, many generics meant to work on arbitrarily many
Reduce> ## arguments can be defined via reduction:
Reduce> FOO <- function(...) Reduce(FOO2, list(...))

Reduce> FOO2 <- function(x, y) UseMethod("FOO2")

Reduce> ## FOO() methods can then be provided via FOO2() methods.
Reduce> 
Reduce> ## A general-purpose cumulative adder:
Reduce> cadd <- function(x) Reduce("+", x, accumulate = TRUE)

Reduce> cadd(seq_len(7))
[1]  1  3  6 10 15 21 28

Reduce> ## A simple function to compute continued fractions:
Reduce> cfrac <- function(x) Reduce(function(u, v) u + 1 / v, x, right = TRUE)

Reduce> ## Continued fraction approximation for pi:
Reduce> cfrac(c(3, 7, 15, 1, 292))
[1] 3.141593

Reduce> ## Continued fraction approximation for Euler's number (e):
Reduce> cfrac(c(2, 1, 2, 1, 1, 4, 1, 1, 6, 1, 1, 8))
[1] 2.718282

Reduce> ## Iterative function application:
Reduce> Funcall <- function(f, ...) f(...)

Reduce> ## Compute log(exp(acos(cos(0))
Reduce> Reduce(Funcall, list(log, exp, acos, cos), 0, right = TRUE)
[1] 0

Reduce> ## n-fold iterate of a function, functional style:
Reduce> Iterate <- function(f, n = 1)
Reduce+     function(x) Reduce(Funcall, rep.int(list(f), n), x, right = TRUE)

Reduce> ## Continued fraction approximation to the golden ratio:
Reduce> Iterate(function(x) 1 + 1 / x, 30)(1)
[1] 1.618034

Reduce> ## which is the same as
Reduce> cfrac(rep.int(1, 31))
[1] 1.618034

Reduce> ## Computing square root approximations for x as fixed points of the
Reduce> ## function t |-> (t + x / t) / 2, as a function of the initial value:
Reduce> asqrt <- function(x, n) Iterate(function(t) (t + x / t) / 2, n)

Reduce> asqrt(2, 30)(10) # Starting from a positive value => +sqrt(2)
[1] 1.414214

Reduce> asqrt(2, 30)(-1) # Starting from a negative value => -sqrt(2)
[1] -1.414214

Reduce> ## A list of all functions in the base environment:
Reduce> funs <- Filter(is.function, sapply(ls(baseenv()), get, baseenv()))

Reduce> ## Functions in base with more than 10 arguments:
Reduce> names(Filter(function(f) length(formals(args(f))) > 10, funs))
[1] "format.default"   "formatC"          "merge.data.frame" "prettyNum"       
[5] "scan"             "source"          

Reduce> ## Number of functions in base with a '...' argument:
Reduce> length(Filter(function(f)
Reduce+               any(names(formals(args(f))) %in% "..."),
Reduce+               funs))
[1] 429

Reduce> ## No test: 
Reduce> ## Find all objects in the base environment which are *not* functions:
Reduce> Filter(Negate(is.function),  sapply(ls(baseenv()), get, baseenv()))
$F
[1] FALSE

$letters
 [1] "a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m" "n" "o" "p" "q" "r" "s"
[20] "t" "u" "v" "w" "x" "y" "z"

$LETTERS
 [1] "A" "B" "C" "D" "E" "F" "G" "H" "I" "J" "K" "L" "M" "N" "O" "P" "Q" "R" "S"
[20] "T" "U" "V" "W" "X" "Y" "Z"

$month.abb
 [1] "Jan" "Feb" "Mar" "Apr" "May" "Jun" "Jul" "Aug" "Sep" "Oct" "Nov" "Dec"

$month.name
 [1] "January"   "February"  "March"     "April"     "May"       "June"     
 [7] "July"      "August"    "September" "October"   "November"  "December" 

$pi
[1] 3.141593

$R.version
               _                           
platform       x86_64-apple-darwin13.4.0   
arch           x86_64                      
os             darwin13.4.0                
system         x86_64, darwin13.4.0        
status                                     
major          3                           
minor          2.1                         
year           2015                        
month          06                          
day            18                          
svn rev        68531                       
language       R                           
version.string R version 3.2.1 (2015-06-18)
nickname       World-Famous Astronaut      

$R.version.string
[1] "R version 3.2.1 (2015-06-18)"

$T
[1] TRUE

$version
               _                           
platform       x86_64-apple-darwin13.4.0   
arch           x86_64                      
os             darwin13.4.0                
system         x86_64, darwin13.4.0        
status                                     
major          3                           
minor          2.1                         
year           2015                        
month          06                          
day            18                          
svn rev        68531                       
language       R                           
version.string R version 3.2.1 (2015-06-18)
nickname       World-Famous Astronaut      


Reduce> ## End(No test)
Reduce> 
Reduce> 
> example(gc, run.donttest = TRUE)

gc> ## No test: 
gc> gc() #- do it now
         used (Mb) gc trigger (Mb) max used (Mb)
Ncells 354562   19     750400 40.1   592000 31.7
Vcells 648696    5    2641813 20.2  3267286 25.0

gc> gcinfo(TRUE) #-- in the future, show when R does it
[1] FALSE

gc> x <- integer(100000); for(i in 1:18) x <- c(x, i)

gc> gcinfo(verbose = FALSE) #-- don't show it anymore
[1] TRUE

gc> gc(TRUE)
Garbage collection 14 = 9+0+5 (level 2) ... 
19.0 Mbytes of cons cells used (47%)
5.4 Mbytes of vectors used (26%)
         used (Mb) gc trigger (Mb) max used (Mb)
Ncells 354549 19.0     750400 40.1   592000 31.7
Vcells 698657  5.4    2641813 20.2  3267286 25.0

gc> gc(reset = TRUE)
         used (Mb) gc trigger (Mb) max used (Mb)
Ncells 354557 19.0     750400 40.1   354557 19.0
Vcells 698689  5.4    2641813 20.2   698689  5.4

gc> ## End(No test)
gc> 
gc> 
> example(memory.profile, run.donttest = TRUE)

mmry.p> ## No test: 
mmry.p> memory.profile()
       NULL      symbol    pairlist     closure environment     promise 
          1        7929      171942        3743         688        5273 
   language     special     builtin        char     logical     integer 
      56837          45         662       10225        6474       21794 
     double     complex   character         ...         any        list 
       1919          21       34844           0           0       15765 
 expression    bytecode externalptr     weakref         raw          S4 
          3       13337        1350         398         400         863 

mmry.p> ## End(No test)
mmry.p> 
mmry.p> 
> paste("Today is", date()) # from paste.Rd
[1] "Today is Fri Jul 17 17:34:49 2015"
> trunc(Sys.time(), "day") # from round.POSIXt.Rd
[1] "2015-07-17 PDT"
> example(srcref, run.donttest = TRUE)

srcref> ## No test: 
srcref>  # has timestamp
srcref> src <- srcfile(system.file("DESCRIPTION", package = "base"))

srcref> summary(src)
/Library/Frameworks/R.framework/Versions/3.2/Resources/library/base/DESCRIPTION 
Timestamp: 2015-06-18 15:25:59 PDT
Encoding: "native.enc"

srcref> getSrcLines(src, 1, 4)
[1] "Package: base"             "Version: 3.2.1"           
[3] "Priority: base"            "Title: The R Base Package"

srcref> ref <- srcref(src, c(1, 1, 2, 1000))

srcref> ref
Package: base
Version: 3.2.1

srcref> print(ref, useSource = FALSE)
<srcref: file "/Library/Frameworks/R.framework/Resources/library/base/DESCRIPTION" chars 1:1 to 2:1000>

srcref> ## End(No test)
srcref> 
srcref> 
> example(strptime, run.donttest = TRUE)

strptm> ## No test: 
strptm> ## locale-specific version of date()
strptm> format(Sys.time(), "%a %b %d %X %Y %Z")
[1] "Fri Jul 17 17:34:49 2015 PDT"

strptm> ## time to sub-second accuracy (if supported by the OS)
strptm> format(Sys.time(), "%H:%M:%OS3")
[1] "17:34:49.921"

strptm> ## read in date info in format 'ddmmmyyyy'
strptm> ## This will give NA(s) in some locales; setting the C locale
strptm> ## as in the commented lines will overcome this on most systems.
strptm> ## lct <- Sys.getlocale("LC_TIME"); Sys.setlocale("LC_TIME", "C")
strptm> x <- c("1jan1960", "2jan1960", "31mar1960", "30jul1960")

strptm> z <- strptime(x, "%d%b%Y")

strptm> ## Sys.setlocale("LC_TIME", lct)
strptm> z
[1] "1960-01-01 PST" "1960-01-02 PST" "1960-03-31 PST" "1960-07-30 PDT"

strptm> ## read in date/time info in format 'm/d/y h:m:s'
strptm> dates <- c("02/27/92", "02/27/92", "01/14/92", "02/28/92", "02/01/92")

strptm> times <- c("23:03:20", "22:29:56", "01:03:30", "18:21:03", "16:56:26")

strptm> x <- paste(dates, times)

strptm> strptime(x, "%m/%d/%y %H:%M:%S")
[1] "1992-02-27 23:03:20 PST" "1992-02-27 22:29:56 PST"
[3] "1992-01-14 01:03:30 PST" "1992-02-28 18:21:03 PST"
[5] "1992-02-01 16:56:26 PST"

strptm> ## time with fractional seconds
strptm> z <- strptime("20/2/06 11:16:16.683", "%d/%m/%y %H:%M:%OS")

strptm> z # prints without fractional seconds
[1] "2006-02-20 11:16:16 PST"

strptm> op <- options(digits.secs = 3)

strptm> z
[1] "2006-02-20 11:16:16.683 PST"

strptm> options(op)

strptm> ## time zones name are not portable, but 'EST5EDT' comes pretty close.
strptm> (x <- strptime(c("2006-01-08 10:07:52", "2006-08-07 19:33:02"),
strptm+                "%Y-%m-%d %H:%M:%S", tz = "EST5EDT"))
[1] "2006-01-08 10:07:52 EST" "2006-08-07 19:33:02 EDT"

strptm> attr(x, "tzone")
[1] "EST5EDT" "EST"     "EDT"    

strptm> ## An RFC 822 header (Eastern Canada, during DST)
strptm> strptime("Tue, 23 Mar 2010 14:36:38 -0400",  "%a, %d %b %Y %H:%M:%S %z")
[1] "2010-03-23 11:36:38"

strptm> ## Make sure you know what the abbreviated names are for you if you wish
strptm> ## to use them for input (they are matched case-insensitively):
strptm> format(seq.Date(as.Date('1978-01-01'), by = 'day', len = 7), "%a")
[1] "Sun" "Mon" "Tue" "Wed" "Thu" "Fri" "Sat"

strptm> format(seq.Date(as.Date('2000-01-01'), by = 'month', len = 12), "%b")
 [1] "Jan" "Feb" "Mar" "Apr" "May" "Jun" "Jul" "Aug" "Sep" "Oct" "Nov" "Dec"

strptm> ## End(No test)
strptm> 
strptm> 
> example(sys.parent, run.donttest = TRUE)

sys.pr> ## No test: 
sys.pr> require(utils)

sys.pr> ## Note: the first two examples will give different results
sys.pr> ## if run by example().
sys.pr> ff <- function(x) gg(x)

sys.pr> gg <- function(y) sys.status()

sys.pr> str(ff(1))
List of 3
 $ sys.calls  :Dotted pair list of 9
  ..$ : language example(sys.parent, run.donttest = TRUE)
  ..$ : language source(tf, local, echo = echo, prompt.echo = paste0(prompt.prefix, getOption("prompt")),      continue.echo = paste0(prompt.prefix, getOption("continue")), verbose = verbose,  ...
  ..$ : language withVisible(eval(ei, envir))
  ..$ : language eval(ei, envir)
  ..$ : language eval(expr, envir, enclos)
  ..$ :length 2 str(ff(1))
  .. ..- attr(*, "srcref")=Class 'srcref'  atomic [1:8] 15 1 15 10 1 10 15 15
  .. .. .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x7ff66b637230> 
  ..$ : language ff(1)
  ..$ :length 2 gg(x)
  .. ..- attr(*, "srcref")=Class 'srcref'  atomic [1:8] 13 7 13 23 7 23 13 13
  .. .. .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x7ff66b637230> 
  ..$ :length 1 sys.status()
  .. ..- attr(*, "srcref")=Class 'srcref'  atomic [1:8] 14 7 14 30 7 30 14 14
  .. .. .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x7ff66b637230> 
 $ sys.parents: int [1:9] 0 1 2 2 4 0 0 7 8
 $ sys.frames :Dotted pair list of 9
  ..$ :<environment: 0x7ff66d7e86a0> 
  ..$ :<environment: 0x7ff66b5a4000> 
  ..$ :<environment: 0x7ff66f2b8158> 
  ..$ :<environment: 0x7ff66f2b8f40> 
  ..$ :<environment: R_GlobalEnv> 
  ..$ :<environment: 0x7ff66f2b8c68> 
  ..$ :<environment: 0x7ff66f2b8aa8> 
  ..$ :<environment: 0x7ff66f2b8958> 
  ..$ :<environment: 0x7ff66f2b88b0> 

sys.pr> gg <- function(y) {
sys.pr+     ggg <- function() {
sys.pr+         cat("current frame is", sys.nframe(), "\n")
sys.pr+         cat("parents are", sys.parents(), "\n")
sys.pr+         print(sys.function(0)) # ggg
sys.pr+         print(sys.function(2)) # gg
sys.pr+     }
sys.pr+     if(y > 0) gg(y-1) else ggg()
sys.pr+ }

sys.pr> gg(3)
current frame is 10 
parents are 0 1 2 2 4 0 6 7 8 9 
function() {
        cat("current frame is", sys.nframe(), "\n")
        cat("parents are", sys.parents(), "\n")
        print(sys.function(0)) # ggg
        print(sys.function(2)) # gg
    }
<environment: 0x7ff66bb05b80>
function (file, local = FALSE, echo = verbose, print.eval = echo, 
    verbose = getOption("verbose"), prompt.echo = getOption("prompt"), 
    max.deparse.length = 150, chdir = FALSE, encoding = getOption("encoding"), 
    continue.echo = getOption("continue"), skip.echo = 0, keep.source = getOption("keep.source")) 
{
    envir <- if (isTRUE(local)) {
        parent.frame()
    }
    else if (identical(local, FALSE)) {
        .GlobalEnv
    }
    else if (is.environment(local)) {
        local
    }
    else stop("'local' must be TRUE, FALSE or an environment")
    have_encoding <- !missing(encoding) && encoding != "unknown"
    if (!missing(echo)) {
        if (!is.logical(echo)) 
            stop("'echo' must be logical")
        if (!echo && verbose) {
            warning("'verbose' is TRUE, 'echo' not; ... coercing 'echo <- TRUE'")
            echo <- TRUE
        }
    }
    if (verbose) {
        cat("'envir' chosen:")
        print(envir)
    }
    ofile <- file
    from_file <- FALSE
    srcfile <- NULL
    if (is.character(file)) {
        if (identical(encoding, "unknown")) {
            enc <- utils::localeToCharset()
            encoding <- enc[length(enc)]
        }
        else enc <- encoding
        if (length(enc) > 1L) {
            encoding <- NA
            owarn <- options(warn = 2)
            for (e in enc) {
                if (is.na(e)) 
                  next
                zz <- file(file, encoding = e)
                res <- tryCatch(readLines(zz, warn = FALSE), 
                  error = identity)
                close(zz)
                if (!inherits(res, "error")) {
                  encoding <- e
                  break
                }
            }
            options(owarn)
        }
        if (is.na(encoding)) 
            stop("unable to find a plausible encoding")
        if (verbose) 
            cat(gettextf("encoding = \"%s\" chosen", encoding), 
                "\n", sep = "")
        if (file == "") {
            file <- stdin()
            srcfile <- "<stdin>"
        }
        else {
            filename <- file
            file <- file(filename, "r", encoding = encoding)
            on.exit(close(file))
            if (isTRUE(keep.source)) {
                lines <- readLines(file, warn = FALSE)
                on.exit()
                close(file)
                srcfile <- srcfilecopy(filename, lines, file.mtime(filename)[1], 
                  isFile = TRUE)
            }
            else {
                from_file <- TRUE
                srcfile <- filename
            }
            loc <- utils::localeToCharset()[1L]
            encoding <- if (have_encoding) 
                switch(loc, `UTF-8` = "UTF-8", `ISO8859-1` = "latin1", 
                  "unknown")
            else "unknown"
        }
    }
    else {
        lines <- readLines(file, warn = FALSE)
        if (isTRUE(keep.source)) 
            srcfile <- srcfilecopy(deparse(substitute(file)), 
                lines)
        else srcfile <- deparse(substitute(file))
    }
    exprs <- if (!from_file) {
        if (length(lines)) 
            .Internal(parse(stdin(), n = -1, lines, "?", srcfile, 
                encoding))
        else expression()
    }
    else .Internal(parse(file, n = -1, NULL, "?", srcfile, encoding))
    on.exit()
    if (from_file) 
        close(file)
    Ne <- length(exprs)
    if (verbose) 
        cat("--> parsed", Ne, "expressions; now eval(.)ing them:\n")
    if (chdir) {
        if (is.character(ofile)) {
            isURL <- length(grep("^(ftp|http|file)://", ofile)) > 
                0L
            if (isURL) 
                warning("'chdir = TRUE' makes no sense for a URL")
            if (!isURL && (path <- dirname(ofile)) != ".") {
                owd <- getwd()
                if (is.null(owd)) 
                  stop("cannot 'chdir' as current directory is unknown")
                on.exit(setwd(owd), add = TRUE)
                setwd(path)
            }
        }
        else {
            warning("'chdir = TRUE' makes no sense for a connection")
        }
    }
    if (echo) {
        sd <- "\""
        nos <- "[^\"]*"
        oddsd <- paste0("^", nos, sd, "(", nos, sd, nos, sd, 
            ")*", nos, "$")
        trySrcLines <- function(srcfile, showfrom, showto) {
            lines <- tryCatch(suppressWarnings(getSrcLines(srcfile, 
                showfrom, showto)), error = function(e) e)
            if (inherits(lines, "error")) 
                character()
            else lines
        }
    }
    yy <- NULL
    lastshown <- 0
    srcrefs <- attr(exprs, "srcref")
    for (i in seq_len(Ne + echo)) {
        tail <- i > Ne
        if (!tail) {
            if (verbose) 
                cat("\n>>>> eval(expression_nr.", i, ")\n\t\t =================\n")
            ei <- exprs[i]
        }
        if (echo) {
            nd <- 0
            srcref <- if (tail) 
                attr(exprs, "wholeSrcref")
            else if (i <= length(srcrefs)) 
                srcrefs[[i]]
            if (!is.null(srcref)) {
                if (i == 1) 
                  lastshown <- min(skip.echo, srcref[3L] - 1)
                if (lastshown < srcref[3L]) {
                  srcfile <- attr(srcref, "srcfile")
                  dep <- trySrcLines(srcfile, lastshown + 1, 
                    srcref[3L])
                  if (length(dep)) {
                    leading <- if (tail) 
                      length(dep)
                    else srcref[1L] - lastshown
                    lastshown <- srcref[3L]
                    while (length(dep) && length(grep("^[[:blank:]]*$", 
                      dep[1L]))) {
                      dep <- dep[-1L]
                      leading <- leading - 1L
                    }
                    dep <- paste0(rep.int(c(prompt.echo, continue.echo), 
                      c(leading, length(dep) - leading)), dep, 
                      collapse = "\n")
                    nd <- nchar(dep, "c")
                  }
                  else srcref <- NULL
                }
            }
            if (is.null(srcref)) {
                if (!tail) {
                  dep <- substr(paste(deparse(ei, control = "showAttributes"), 
                    collapse = "\n"), 12L, 1000000L)
                  dep <- paste0(prompt.echo, gsub("\n", paste0("\n", 
                    continue.echo), dep))
                  nd <- nchar(dep, "c") - 1L
                }
            }
            if (nd) {
                do.trunc <- nd > max.deparse.length
                dep <- substr(dep, 1L, if (do.trunc) 
                  max.deparse.length
                else nd)
                cat("\n", dep, if (do.trunc) 
                  paste(if (length(grep(sd, dep)) && length(grep(oddsd, 
                    dep))) 
                    " ...\" ..."
                  else " ....", "[TRUNCATED] "), "\n", sep = "")
            }
        }
        if (!tail) {
            yy <- withVisible(eval(ei, envir))
            i.symbol <- mode(ei[[1L]]) == "name"
            if (!i.symbol) {
                curr.fun <- ei[[1L]][[1L]]
                if (verbose) {
                  cat("curr.fun:")
                  utils::str(curr.fun)
                }
            }
            if (verbose >= 2) {
                cat(".... mode(ei[[1L]])=", mode(ei[[1L]]), "; paste(curr.fun)=")
                utils::str(paste(curr.fun))
            }
            if (print.eval && yy$visible) {
                if (isS4(yy$value)) 
                  methods::show(yy$value)
                else print(yy$value)
            }
            if (verbose) 
                cat(" .. after ", sQuote(deparse(ei, control = c("showAttributes", 
                  "useSource"))), "\n", sep = "")
        }
    }
    invisible(yy)
}
<bytecode: 0x7ff66de23388>
<environment: namespace:base>

sys.pr> t1 <- function() {
sys.pr+   aa <- "here"
sys.pr+   t2 <- function() {
sys.pr+     ## in frame 2 here
sys.pr+     cat("current frame is", sys.nframe(), "\n")
sys.pr+     str(sys.calls()) ## list with two components t1() and t2()
sys.pr+     cat("parents are frame numbers", sys.parents(), "\n") ## 0 1
sys.pr+     print(ls(envir = sys.frame(-1))) ## [1] "aa" "t2"
sys.pr+     invisible()
sys.pr+   }
sys.pr+   t2()
sys.pr+ }

sys.pr> t1()
current frame is 7 
Dotted pair list of 7
 $ : language example(sys.parent, run.donttest = TRUE)
 $ : language source(tf, local, echo = echo, prompt.echo = paste0(prompt.prefix, getOption("prompt")),      continue.echo = paste0(prompt.prefix, getOption("continue")), verbose = verbose,  ...
 $ : language withVisible(eval(ei, envir))
 $ : language eval(ei, envir)
 $ : language eval(expr, envir, enclos)
 $ :length 1 t1()
  ..- attr(*, "srcref")=Class 'srcref'  atomic [1:8] 40 1 40 4 1 4 40 40
  .. .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x7ff66b637230> 
 $ :length 1 t2()
  ..- attr(*, "srcref")=Class 'srcref'  atomic [1:8] 38 3 38 6 3 6 38 38
  .. .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x7ff66b637230> 
parents are frame numbers 0 1 2 2 4 0 6 
[1] "aa" "t2"

sys.pr> test.sys.on.exit <- function() {
sys.pr+   on.exit(print(1))
sys.pr+   ex <- sys.on.exit()
sys.pr+   str(ex)
sys.pr+   cat("exiting...\n")
sys.pr+ }

sys.pr> test.sys.on.exit()
 language print(1)
exiting...
[1] 1

sys.pr> ## gives 'language print(1)', prints 1 on exit
sys.pr> 
sys.pr> ## An example where the parent is not the next frame up the stack
sys.pr> ## since method dispatch uses a frame.
sys.pr> as.double.foo <- function(x)
sys.pr+ {
sys.pr+     str(sys.calls())
sys.pr+     print(sys.frames())
sys.pr+     print(sys.parents())
sys.pr+     print(sys.frame(-1)); print(parent.frame())
sys.pr+     x
sys.pr+ }

sys.pr> t2 <- function(x) as.double(x)

sys.pr> a <- structure(pi, class = "foo")

sys.pr> t2(a)
Dotted pair list of 8
 $ : language example(sys.parent, run.donttest = TRUE)
 $ : language source(tf, local, echo = echo, prompt.echo = paste0(prompt.prefix, getOption("prompt")),      continue.echo = paste0(prompt.prefix, getOption("continue")), verbose = verbose,  ...
 $ : language withVisible(eval(ei, envir))
 $ : language eval(ei, envir)
 $ : language eval(expr, envir, enclos)
 $ :length 2 t2(a)
  ..- attr(*, "srcref")=Class 'srcref'  atomic [1:8] 63 1 63 5 1 5 63 63
  .. .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x7ff66b637230> 
 $ :length 2 as.double(x)
  ..- attr(*, "srcref")=Class 'srcref'  atomic [1:8] 61 7 61 30 7 30 61 61
  .. .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x7ff66b637230> 
 $ :length 2 as.double.foo(x)
  ..- attr(*, "srcref")=Class 'srcref'  atomic [1:8] 61 7 61 30 7 30 61 61
  .. .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x7ff66b637230> 
[[1]]
<environment: 0x7ff66d7e86a0>

[[2]]
<environment: 0x7ff66b5a4000>

[[3]]
<environment: 0x7ff66bd2b230>

[[4]]
<environment: 0x7ff66bd2b070>

[[5]]
<environment: R_GlobalEnv>

[[6]]
<environment: 0x7ff66bd2bd78>

[[7]]
<environment: 0x7ff66bd2bbf0>

[[8]]
<environment: 0x7ff66bd2b9c0>

[1] 0 1 2 2 4 0 6 6
<environment: 0x7ff66bd2bbf0>
<environment: 0x7ff66bd2bd78>
[1] 3.141593
attr(,"class")
[1] "foo"

sys.pr> ## End(No test)
sys.pr> 
sys.pr> 
> example(system.time, run.donttest = TRUE)

systm.> require(stats)

systm.> ## No test: 
systm.> system.time(for(i in 1:100) mad(runif(1000)))
   user  system elapsed 
  0.012   0.001   0.013 

systm.> ## End(No test)
systm.> ## Not run: 
systm.> ##D exT <- function(n = 10000) {
systm.> ##D   # Purpose: Test if system.time works ok;   n: loop size
systm.> ##D   system.time(for(i in 1:n) x <- mean(rt(1000, df = 4)))
systm.> ##D }
systm.> ##D #-- Try to interrupt one of the following (using Ctrl-C / Escape):
systm.> ##D exT()                 #- about 4 secs on a 2.5GHz Xeon
systm.> ##D system.time(exT())    #~ +/- same
systm.> ## End(Not run)
systm.> 
systm.> 
> example(tempfile, run.donttest = TRUE)

tempfl> ## No test: 
tempfl> tempfile(c("ab", "a b c"))   # give file name with spaces in!
[1] "/var/folders/83/l9__ksh126ggwyp9lq9qbkt00000gn/T//RtmpLMpUxn/ab1206c6aaccc3"    
[2] "/var/folders/83/l9__ksh126ggwyp9lq9qbkt00000gn/T//RtmpLMpUxn/a b c1206c376919a0"

tempfl> tempfile("plot", fileext = c(".ps", ".pdf"))
[1] "/var/folders/83/l9__ksh126ggwyp9lq9qbkt00000gn/T//RtmpLMpUxn/plot1206c551173cb.ps" 
[2] "/var/folders/83/l9__ksh126ggwyp9lq9qbkt00000gn/T//RtmpLMpUxn/plot1206c6cc9400e.pdf"

tempfl> tempdir() # works on all platforms with a platform-dependent result
[1] "/var/folders/83/l9__ksh126ggwyp9lq9qbkt00000gn/T//RtmpLMpUxn"

tempfl> ## End(No test)
tempfl> 
tempfl> 
> example(weekdays, run.donttest = TRUE)

wekdys> ## No test: 
wekdys> weekdays(.leap.seconds)
 [1] "Friday"    "Sunday"    "Monday"    "Tuesday"   "Wednesday" "Friday"   
 [7] "Saturday"  "Sunday"    "Monday"    "Tuesday"   "Wednesday" "Thursday" 
[13] "Sunday"    "Thursday"  "Sunday"    "Monday"    "Tuesday"   "Wednesday"
[19] "Thursday"  "Sunday"    "Monday"    "Thursday"  "Saturday"  "Wednesday"
[25] "Saturday" 

wekdys> months(.leap.seconds)
 [1] "June"     "December" "December" "December" "December" "December"
 [7] "December" "December" "December" "June"     "June"     "June"    
[13] "June"     "December" "December" "December" "June"     "June"    
[19] "June"     "December" "June"     "December" "December" "December"
[25] "June"    

wekdys> quarters(.leap.seconds)
 [1] "Q2" "Q4" "Q4" "Q4" "Q4" "Q4" "Q4" "Q4" "Q4" "Q2" "Q2" "Q2" "Q2" "Q4" "Q4"
[16] "Q4" "Q2" "Q2" "Q2" "Q4" "Q2" "Q4" "Q4" "Q4" "Q2"

wekdys> ## Julian Day Number (JDN, http://en.wikipedia.org/wiki/Julian_day)
wekdys> ## is the number of days since noon UTC on the first day of 4317 BC.
wekdys> ## in the proleptic Julian calendar.  To more recently, in
wekdys> ## 'Terrestrial Time' which differs from UTC by a few seconds
wekdys> ## See http://en.wikipedia.org/wiki/Terrestrial_Time
wekdys> julian(Sys.Date(), -2440588) # from a day
[1] 2457221
attr(,"origin")
[1] -2440588

wekdys> floor(as.numeric(julian(Sys.time())) + 2440587.5) # from a date-time
[1] 2457221

wekdys> ## End(No test)
wekdys> 
wekdys> 
> library(help = "splines")

		Information on package ‘splines’

Description:

Package:       splines
Version:       3.2.1
Priority:      base
Imports:       graphics, stats
Title:         Regression Spline Functions and Classes
Author:        Douglas M. Bates <bates@stat.wisc.edu> and William N.
               Venables <Bill.Venables@csiro.au>
Maintainer:    R Core Team <R-core@r-project.org>
Description:   Regression spline functions and classes.
License:       Part of R 3.2.1
Built:         R 3.2.1; x86_64-apple-darwin13.4.0; 2015-06-18 22:21:07
               UTC; unix

Index:

asVector                Coerce an Object to a Vector
backSpline              Monotone Inverse Spline
bs                      B-Spline Basis for Polynomial Splines
interpSpline            Create an Interpolation Spline
ns                      Generate a Basis Matrix for Natural Cubic
                        Splines
periodicSpline          Create a Periodic Interpolation Spline
polySpline              Piecewise Polynomial Spline Representation
predict.bSpline         Evaluate a Spline at New Values of x
predict.bs              Evaluate a Spline Basis
splineDesign            Design Matrix for B-splines
splineKnots             Knot Vector from a Spline
splineOrder             Determine the Order of a Spline
splines-package         Regression Spline Functions and Classes
xyVector                Construct an 'xyVector' Object

> 
> ## for example(NA)
> if(require("microbenchmark")) {
+   x <- c(NaN, 1:10000)
+   print(microbenchmark(any(is.na(x)), anyNA(x)))
+ } else { ## much less accurate
+   x <- c(NaN, 1e6)
+   nSim <- 2^13
+   print(rbind(is.na = system.time(replicate(nSim, any(is.na(x)))),
+               anyNA = system.time(replicate(nSim, anyNA(x)))))
+ }
Loading required package: microbenchmark
Unit: nanoseconds
          expr  min    lq     mean  median    uq   max neval
 any(is.na(x)) 8433 21656 21903.09 22508.0 23464 74532   100
      anyNA(x)  104   120   175.20   162.5   179  1807   100
> 
> ## utils
> example(news, run.donttest = TRUE)

news> ## Build a db of all R news entries.
news> db <- news()

news> ## Don't show: 
news>   vv <- capture.output(db)  # without an error

news> ## End(Don't show)
news> ## Bug fixes with PR number in 3.0.1.
news> db3 <- news(Version == "3.0.1" & grepl("^BUG", Category) & grepl("PR#", Text),
news+             db = db)

news> ## Don't show: 
news> stopifnot( !any(attr(db3,"bad")) && nrow(db3) == 12 )

news> ## End(Don't show)
news> 
news> ## News from a date range ('Matrix' is there in a regular R installation):
news> if(length(iM <- find.package("Matrix", quiet=TRUE)) && nzchar(iM)) {
news+    dM <- news(package="Matrix")
news+    dM2014 <- news("2014-01-01" <= Date & Date <= "2014-12-31", db = dM)
news+    stopifnot(paste0("1.1-", 2:4) %in% dM2014[,"Version"])
news+ }

news> ## No test: 
news> ## Which categories have been in use? % R-core maybe should standardize a bit more
news> sort(table(db[, "Category"]), decreasing = TRUE)

                      NEW FEATURES                          BUG FIXES 
                               323                                310 
                         UTILITIES             DEPRECATED AND DEFUNCT 
                                52                                 45 
INSTALLATION and INCLUDED SOFTWARE                 C-LEVEL FACILITIES 
                                35                                 33 
              PACKAGE INSTALLATION                       LONG VECTORS 
                                25                                 13 
                      INSTALLATION           PERFORMANCE IMPROVEMENTS 
                                10                                  7 
                         DEBUGGING               INTERNATIONALIZATION 
                                 5                                  5 
  SIGNIFICANT USER-VISIBLE CHANGES              WINDOWS BUILD CHANGES 
                                 4                                  4 
                    CODE MIGRATION                   PACKAGE parallel 
                                 3                                  3 
                     DOCUMENTATION 
                                 1 

news> ## Entries with version >= 3.0.0 (including "3.0.0 patched"):
news> table(news(Version >= "3.0.0", db = db)$Version)

3.0.0 3.0.1 3.0.2 3.0.3 3.1.0 3.1.1 3.1.2 3.1.3 3.2.0 3.2.1 
  219    36   118    70   130    58    51    50   116    30 

news> ## End(No test)
news> 
news> 
> example(sessionInfo, run.donttest = TRUE)

sssnIn> ## No test: 
sssnIn> sessionInfo()
R version 3.2.1 (2015-06-18)
Platform: x86_64-apple-darwin13.4.0 (64-bit)
Running under: OS X 10.10.4 (Yosemite)

locale:
[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8

attached base packages:
[1] stats     graphics  grDevices utils     datasets  methods   base     

other attached packages:
[1] microbenchmark_1.4-2

loaded via a namespace (and not attached):
 [1] MASS_7.3-40      colorspace_1.2-6 scales_0.2.5     magrittr_1.5    
 [5] plyr_1.8.3       tools_3.2.1      gtable_0.1.2     reshape2_1.4.1  
 [9] Rcpp_0.11.6      ggplot2_1.0.1    stringi_0.5-5    grid_3.2.1      
[13] stringr_1.0.0    digest_0.6.8     proto_0.3-10     munsell_0.4.2   

sssnIn> toLatex(sessionInfo(), locale = FALSE)
\begin{itemize}\raggedright
  \item R version 3.2.1 (2015-06-18), \verb|x86_64-apple-darwin13.4.0|
  \item Base packages: base, datasets, graphics, grDevices, methods,
    stats, utils
  \item Other packages: microbenchmark~1.4-2
  \item Loaded via a namespace (and not attached): colorspace~1.2-6,
    digest~0.6.8, ggplot2~1.0.1, grid~3.2.1, gtable~0.1.2,
    magrittr~1.5, MASS~7.3-40, munsell~0.4.2, plyr~1.8.3, proto~0.3-10,
    Rcpp~0.11.6, reshape2~1.4.1, scales~0.2.5, stringi~0.5-5,
    stringr~1.0.0, tools~3.2.1
\end{itemize}

sssnIn> ## End(No test)
sssnIn> 
sssnIn> 
> 
> ## datasets
> example(JohnsonJohnson, run.donttest = TRUE)

JhnsnJ> ## No test: 
JhnsnJ> require(stats); require(graphics)

JhnsnJ> JJ <- log10(JohnsonJohnson)

JhnsnJ> plot(JJ)

JhnsnJ> ## This example gives a possible-non-convergence warning on some
JhnsnJ> ## platforms, but does seem to converge on x86 Linux and Windows.
JhnsnJ> (fit <- StructTS(JJ, type = "BSM"))

Call:
StructTS(x = JJ, type = "BSM")

Variances:
    level      slope       seas    epsilon  
1.948e-04  6.548e-06  4.138e-04  2.647e-04  

JhnsnJ> tsdiag(fit)

JhnsnJ> sm <- tsSmooth(fit)

JhnsnJ> plot(cbind(JJ, sm[, 1], sm[, 3]-0.5), plot.type = "single",
JhnsnJ+      col = c("black", "green", "blue"))

JhnsnJ> abline(h = -0.5, col = "grey60")

JhnsnJ> monthplot(fit)

JhnsnJ> ## End(No test)
JhnsnJ> 
JhnsnJ> 
> example(ability.cov, run.donttest = TRUE)

ablty.> ## No test: 
ablty.> require(stats)

ablty.> (ability.FA <- factanal(factors = 1, covmat = ability.cov))

Call:
factanal(factors = 1, covmat = ability.cov)

Uniquenesses:
general picture  blocks    maze reading   vocab 
  0.535   0.853   0.748   0.910   0.232   0.280 

Loadings:
        Factor1
general 0.682  
picture 0.384  
blocks  0.502  
maze    0.300  
reading 0.877  
vocab   0.849  

               Factor1
SS loadings      2.443
Proportion Var   0.407

Test of the hypothesis that 1 factor is sufficient.
The chi square statistic is 75.18 on 9 degrees of freedom.
The p-value is 1.46e-12 

ablty.> update(ability.FA, factors = 2)

Call:
factanal(factors = 2, covmat = ability.cov)

Uniquenesses:
general picture  blocks    maze reading   vocab 
  0.455   0.589   0.218   0.769   0.052   0.334 

Loadings:
        Factor1 Factor2
general 0.499   0.543  
picture 0.156   0.622  
blocks  0.206   0.860  
maze    0.109   0.468  
reading 0.956   0.182  
vocab   0.785   0.225  

               Factor1 Factor2
SS loadings      1.858   1.724
Proportion Var   0.310   0.287
Cumulative Var   0.310   0.597

Test of the hypothesis that 2 factors are sufficient.
The chi square statistic is 6.11 on 4 degrees of freedom.
The p-value is 0.191 

ablty.> ## The signs of factors and hence the signs of correlations are
ablty.> ## arbitrary with promax rotation.
ablty.> update(ability.FA, factors = 2, rotation = "promax")

Call:
factanal(factors = 2, covmat = ability.cov, rotation = "promax")

Uniquenesses:
general picture  blocks    maze reading   vocab 
  0.455   0.589   0.218   0.769   0.052   0.334 

Loadings:
        Factor1 Factor2
general  0.364   0.470 
picture          0.671 
blocks           0.932 
maze             0.508 
reading  1.023         
vocab    0.811         

               Factor1 Factor2
SS loadings      1.853   1.807
Proportion Var   0.309   0.301
Cumulative Var   0.309   0.610

Factor Correlations:
        Factor1 Factor2
Factor1   1.000   0.557
Factor2   0.557   1.000

Test of the hypothesis that 2 factors are sufficient.
The chi square statistic is 6.11 on 4 degrees of freedom.
The p-value is 0.191 

ablty.> ## End(No test)
ablty.> 
ablty.> 
> example(npk, run.donttest = TRUE)

npk> ## No test: 
npk> options(contrasts = c("contr.sum", "contr.poly"))

npk> npk.aov <- aov(yield ~ block + N*P*K, npk)

npk> npk.aov
Call:
   aov(formula = yield ~ block + N * P * K, data = npk)

Terms:
                   block        N        P        K      N:P      N:K      P:K
Sum of Squares  343.2950 189.2817   8.4017  95.2017  21.2817  33.1350   0.4817
Deg. of Freedom        5        1        1        1        1        1        1
                Residuals
Sum of Squares   185.2867
Deg. of Freedom        12

Residual standard error: 3.929447
1 out of 13 effects not estimable
Estimated effects may be unbalanced

npk> summary(npk.aov)
            Df Sum Sq Mean Sq F value  Pr(>F)   
block        5  343.3   68.66   4.447 0.01594 * 
N            1  189.3  189.28  12.259 0.00437 **
P            1    8.4    8.40   0.544 0.47490   
K            1   95.2   95.20   6.166 0.02880 * 
N:P          1   21.3   21.28   1.378 0.26317   
N:K          1   33.1   33.14   2.146 0.16865   
P:K          1    0.5    0.48   0.031 0.86275   
Residuals   12  185.3   15.44                   
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

npk> coef(npk.aov)
(Intercept)      block1      block2      block3      block4      block5 
 54.8750000  -0.8500000   2.5750000   5.9000000  -4.7500000  -4.3500000 
         N1          P1          K1       N1:P1       N1:K1       P1:K1 
 -2.8083333   0.5916667   1.9916667  -0.9416667  -1.1750000   0.1416667 

npk> options(contrasts = c("contr.treatment", "contr.poly"))

npk> npk.aov1 <- aov(yield ~ block + N + K, data = npk)

npk> summary.lm(npk.aov1)

Call:
aov(formula = yield ~ block + N + K, data = npk)

Residuals:
    Min      1Q  Median      3Q     Max 
-6.4083 -2.1438  0.2042  2.3292  7.0750 

Coefficients:
            Estimate Std. Error t value Pr(>|t|)    
(Intercept)   53.208      2.276  23.381  8.5e-14 ***
block2         3.425      2.787   1.229  0.23690    
block3         6.750      2.787   2.422  0.02769 *  
block4        -3.900      2.787  -1.399  0.18082    
block5        -3.500      2.787  -1.256  0.22723    
block6         2.325      2.787   0.834  0.41646    
N1             5.617      1.609   3.490  0.00302 ** 
K1            -3.983      1.609  -2.475  0.02487 *  
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

Residual standard error: 3.942 on 16 degrees of freedom
Multiple R-squared:  0.7163,	Adjusted R-squared:  0.5922 
F-statistic: 5.772 on 7 and 16 DF,  p-value: 0.001805


npk> se.contrast(npk.aov1, list(N=="0", N=="1"), data = npk)
[1] 1.609175

npk> model.tables(npk.aov1, type = "means", se = TRUE)
Tables of means
Grand mean
       
54.875 

 block 
block
    1     2     3     4     5     6 
54.03 57.45 60.77 50.12 50.52 56.35 

 N 
N
    0     1 
52.07 57.68 

 K 
K
    0     1 
56.87 52.88 

Standard errors for differences of means
        block     N     K
        2.787 1.609 1.609
replic.     4    12    12

npk> ## End(No test)
npk> 
npk> 
> 
> ## grDevices
> example(grSoftVersion, run.donttest = TRUE)

grSftV> ## No test: 
grSftV> grSoftVersion()
                   cairo                   libpng                     jpeg 
                "1.14.2"                 "1.6.17"                    "9.1" 
                 libtiff 
"LIBTIFF, Version 4.0.3" 

grSftV> ## End(No test)
grSftV> 
grSftV> 
grSftV> 
> if(.Platform$OS.type == "windows") {
+     example(windowsFonts, run.donttest = TRUE)
+ } else {
+     example(X11Fonts, run.donttest = TRUE)
+     example(quartzFonts, run.donttest = TRUE)
+ }

X11Fnt> X11Fonts()
$serif
[1] "-*-times-%s-%s-*-*-%d-*-*-*-*-*-*-*"

$sans
[1] "-*-helvetica-%s-%s-*-*-%d-*-*-*-*-*-*-*"

$mono
[1] "-*-courier-%s-%s-*-*-%d-*-*-*-*-*-*-*"

$Times
[1] "-adobe-times-%s-%s-*-*-%d-*-*-*-*-*-*-*"

$Helvetica
[1] "-adobe-helvetica-%s-%s-*-*-%d-*-*-*-*-*-*-*"

$CyrTimes
[1] "-cronyx-times-%s-%s-*-*-%d-*-*-*-*-*-*-*"

$CyrHelvetica
[1] "-cronyx-helvetica-%s-%s-*-*-%d-*-*-*-*-*-*-*"

$Arial
[1] "-monotype-arial-%s-%s-*-*-%d-*-*-*-*-*-*-*"

$Mincho
[1] "-*-mincho-%s-%s-*-*-%d-*-*-*-*-*-*-*"


X11Fnt> X11Fonts("mono")
$mono
[1] "-*-courier-%s-%s-*-*-%d-*-*-*-*-*-*-*"


X11Fnt> utopia <- X11Font("-*-utopia-*-*-*-*-*-*-*-*-*-*-*-*")

X11Fnt> X11Fonts(utopia = utopia)

qrtzFn> quartzFonts()
$serif
[1] "Times-Roman"      "Times-Bold"       "Times-Italic"     "Times-BoldItalic"

$sans
[1] "Helvetica"             "Helvetica-Bold"        "Helvetica-Oblique"    
[4] "Helvetica-BoldOblique"

$mono
[1] "Courier"             "Courier-Bold"        "Courier-Oblique"    
[4] "Courier-BoldOblique"


qrtzFn> quartzFonts("mono")
$mono
[1] "Courier"             "Courier-Bold"        "Courier-Oblique"    
[4] "Courier-BoldOblique"


qrtzFn> ## Not run: 
qrtzFn> ##D ## for CJK locales you can use something like
qrtzFn> ##D quartzFonts(sans = quartzFont(rep("AppleGothic", 4)),
qrtzFn> ##D             serif = quartzFont(rep("AppleMyungjp", 4)))
qrtzFn> ##D ## since the default fonts may well not have the glyphs needed
qrtzFn> ## End(Not run)
qrtzFn> 
qrtzFn> 
> 
> library(tools)
> example(Rdutils, run.donttest = TRUE)
Warning message:
In example(Rdutils, run.donttest = TRUE) : no help found for ‘Rdutils’
> example(fileutils, run.donttest = TRUE)
Warning message:
In example(fileutils, run.donttest = TRUE) : no help found for ‘fileutils’
> ## results are location- and OS-specific
> example(parseLatex, run.donttest = TRUE) # charset-specific

prsLtx> ## No test: 
prsLtx> latex <- parseLatex("fa\\c{c}ile")

prsLtx> deparseLatex(latexToUtf8(latex))
[1] "façile"

prsLtx> ## End(No test)
prsLtx> 
prsLtx> 
> example(loadRdMacros, run.donttest = TRUE) # collation-specific

ldRdMc> ## No test: 
ldRdMc> f <- tempfile()

ldRdMc> writeLines(paste0("\\newcommand{\\logo}{\\if{html}{\\figure{logo.jpg}}",
ldRdMc+                   "\\if{latex}{\\figure{logo.jpg}{options: width=0.5in}}}"),
ldRdMc+ 	    f)

ldRdMc> m <- loadRdMacros(f)

ldRdMc> ls(m)
[1] "\\logo"

ldRdMc> ls(parent.env(m))
 [1] "\\acronym"      "\\alias"        "\\arguments"    "\\author"      
 [5] "\\bold"         "\\cite"         "\\code"         "\\command"     
 [9] "\\concept"      "\\cr"           "\\deqn"         "\\describe"    
[13] "\\description"  "\\details"      "\\dfn"          "\\docType"     
[17] "\\dontrun"      "\\dontshow"     "\\donttest"     "\\dots"        
[21] "\\dQuote"       "\\email"        "\\emph"         "\\enc"         
[25] "\\encoding"     "\\enumerate"    "\\env"          "\\eqn"         
[29] "\\examples"     "\\figure"       "\\file"         "\\format"      
[33] "\\href"         "\\if"           "\\ifelse"       "\\item"        
[37] "\\itemize"      "\\kbd"          "\\keyword"      "\\ldots"       
[41] "\\link"         "\\linkS4class"  "\\method"       "\\name"        
[45] "\\newcommand"   "\\note"         "\\option"       "\\out"         
[49] "\\pkg"          "\\preformatted" "\\R"            "\\RdOpts"      
[53] "\\Rdversion"    "\\references"   "\\renewcommand" "\\S3method"    
[57] "\\S4method"     "\\samp"         "\\section"      "\\seealso"     
[61] "\\Sexpr"        "\\source"       "\\special"      "\\sQuote"      
[65] "\\strong"       "\\subsection"   "\\synopsis"     "\\tab"         
[69] "\\tabular"      "\\testonly"     "\\title"        "\\url"         
[73] "\\usage"        "\\value"        "\\var"          "\\verb"        
[77] "#endif"         "#ifdef"         "#ifndef"       

ldRdMc> ls(parent.env(parent.env(m)))
character(0)

ldRdMc> ## End(No test)
ldRdMc> 
ldRdMc> 
ldRdMc> 
> 
> ## part of example(buildVignettes) at one time
> gVigns <- pkgVignettes("grid")
> str(gVigns) # contains paths
List of 8
 $ docs     : chr [1:13] "/Library/Frameworks/R.framework/Versions/3.2/Resources/library/grid/doc/displaylist.Rnw" "/Library/Frameworks/R.framework/Versions/3.2/Resources/library/grid/doc/frame.Rnw" "/Library/Frameworks/R.framework/Versions/3.2/Resources/library/grid/doc/grid.Rnw" "/Library/Frameworks/R.framework/Versions/3.2/Resources/library/grid/doc/grobs.Rnw" ...
 $ names    : chr [1:13] "displaylist" "frame" "grid" "grobs" ...
 $ engines  : chr [1:13] "utils::Sweave" "utils::Sweave" "utils::Sweave" "utils::Sweave" ...
 $ patterns : chr [1:13] "[.][rRsS](nw|tex)$" "[.][rRsS](nw|tex)$" "[.][rRsS](nw|tex)$" "[.][rRsS](nw|tex)$" ...
 $ encodings: Named chr [1:13] "" "" "" "" ...
  ..- attr(*, "names")= chr [1:13] "/Library/Frameworks/R.framework/Versions/3.2/Resources/library/grid/doc/displaylist.Rnw" "/Library/Frameworks/R.framework/Versions/3.2/Resources/library/grid/doc/frame.Rnw" "/Library/Frameworks/R.framework/Versions/3.2/Resources/library/grid/doc/grid.Rnw" "/Library/Frameworks/R.framework/Versions/3.2/Resources/library/grid/doc/grobs.Rnw" ...
 $ dir      : chr "/Library/Frameworks/R.framework/Versions/3.2/Resources/library/grid/doc"
 $ pkgdir   : chr "/Library/Frameworks/R.framework/Versions/3.2/Resources/library/grid"
 $ msg      : chr(0) 
 - attr(*, "class")= chr "pkgVignettes"
> 
> vind <- system.file(package = "grid", "doc", "index.html")
> if(nzchar(vind)) { # so vignettes have been installed
+     `%=f=%` <- function(a, b) normalizePath(a) == normalizePath(b)
+     with(gVigns,
+          stopifnot(engines == "utils::Sweave",
+                    pkgdir %=f=% system.file(package="grid"),
+                    dir    %=f=% system.file(package = "grid", "doc"),
+                    (n. <- length(docs)) >= 12, # have 13
+                    n. == length(names), n. == length(engines),
+                    length(msg) == 0) ) # as it is a 'base' package
+     stopifnot("grid" %in% gVigns$names, inherits(gVigns, "pkgVignettes"))
+ }
> 
> ## This might leave collation changed, so do not put other things after it.
> example(icuSetCollate, run.donttest = TRUE)

icStCl> ## No test: 
icStCl> ## These examples depend on having ICU available, and on the locale.
icStCl> ## As we don't know the current settings, we can only reset to the default.
icStCl> if(capabilities("ICU")) {
icStCl+     print(icuGetCollate())
icStCl+     print(icuGetCollate("valid"))
icStCl+     x <- c("Aarhus", "aarhus", "safe", "test", "Zoo")
icStCl+     print(sort(x))
icStCl+     icuSetCollate(case_first = "upper"); print(sort(x))
icStCl+     icuSetCollate(case_first = "lower"); print(sort(x))
icStCl+ 
icStCl+     ## Danish collates upper-case-first and with 'aa' as a single letter
icStCl+     icuSetCollate(locale = "da_DK", case_first = "default"); print(sort(x)) 
icStCl+     ## Estonian collates Z between S and T
icStCl+     icuSetCollate(locale = "et_EE"); print(sort(x))
icStCl+     icuSetCollate(locale = "default"); print(icuGetCollate("valid"))
icStCl+ }
[1] "root"
[1] "en"
[1] "aarhus" "Aarhus" "safe"   "test"   "Zoo"   
[1] "Aarhus" "aarhus" "safe"   "test"   "Zoo"   
[1] "aarhus" "Aarhus" "safe"   "test"   "Zoo"   
[1] "safe"   "test"   "Zoo"    "Aarhus" "aarhus"
[1] "aarhus" "Aarhus" "safe"   "Zoo"    "test"  
[1] "en"

icStCl> ## End(No test)
icStCl> 
icStCl> 
> proc.time()
   user  system elapsed 
  2.884   0.216   6.884 
> 
> proc.time()
   user  system elapsed 
  2.884   0.216   6.884 
